---
title: "Learning Go"
author: "jeffsims"
cover: "./images/hero.png"
category: "golang"
date: "2019-11-09"
slug: "learning-go"
tags:
    - golang
    - learning
---

I've decided to venture from my JavaScript comfort zone and really dive into [Go](https://golang.org/).  I love looking at new languages, but usually only look at them at a very high level.  I plan to dive much deeper into Go.

I've attempted to get into Go a few times over the last couple years by going through the [Tour of Go](https://tour.golang.org/welcome/1) and reading through the [Go Programming Book](https://www.amazon.com/Programming-Language-Addison-Wesley-Professional-Computing/dp/0134190440).  I just could never get into either of those resources and would end up bailing on learning Go entirely.  I have a new plan this time and so far it's going really well.

First, I've been going through [Learn Go with Tests](https://quii.gitbook.io/learn-go-with-tests/).  It's been excellent thus far.  Concepts like slices and interfaces that didn't click before are clicking now.  I should be finishing this tutorial in the next few days.

Once I complete Learn Go with Tests, I plan to start [Writing an Interpreter in Go](https://interpreterbook.com/) by Thorsten Ball.  I've started this book a few times but always would get hung up on syntax.  With a base from going through Learn Go with Tests, I hope to be able to make it all the way through this book.

Next, I'll go through the next book by Thorsten, [Writing a Compiler in Go](https://compilerbook.com/).  I've wanted to learn about compilers for awhile and am a sucker for books and tutorials that have you build something tangible from scratch.  I learn the best by doing stuff like that.  As for the compiler, I read a great [quote](https://twitter.com/orta/status/1193002821685256192) about writing compilers for learning exercises:

> Writing a compiler is the software equivalent to taking LSD.

> It fundamentally alters your perception of the world. Hard problems get simpler. All the mysterious, arcane, and unknowable pieces of computing are reduced to a small, easy to grasp set of principles. And once you understand well how the machine executes code, your ability to reason about the performance of other code improves dramatically.

I'm really looking forward to having my mind expanded.